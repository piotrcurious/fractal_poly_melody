
// Arduino sketch playing arpeggios generated by LFSR generated polynomials combinations converging to symmetrical fractal chords

// Define the pins for the speaker, the buttons and the knob
#define SPEAKER_PIN 9
#define GENERATE_PIN 2 // Button to generate a new sequence
#define EVOLVE_PIN 3 // Button to evolve the current sequence
#define REPEAT_PIN 4 // Button to repeat the current sequence
#define KNOB_PIN A0 // Knob to set the target function

// Define the notes and frequencies for the arpeggios
#define C4 262
#define D4 294
#define E4 330
#define F4 349
#define G4 392
#define A4 440
#define B4 494
#define C5 523

// Define the duration of each note in milliseconds
#define NOTE_DURATION 100

// Define the LFSR parameters
#define LFSR_SEED 0xACE1 // Initial state of the LFSR
#define LFSR_MASK 0xB400 // Polynomial mask for the LFSR

// Define the number of polynomials to combine
#define POLY_COUNT 3

// Define the number of iterations to converge to a fractal chord
#define ITER_COUNT 5

// Define the learning rate for gradient descent
#define LEARNING_RATE 0.01

// Define the number of harmonizing jazz progressions
#define PROG_COUNT 32

// Define an array of harmonizing jazz progressions as target functions (using sin(x) as a placeholder)
uint16_t progs[PROG_COUNT] = {
  (C4 + E4 + G4 + B4) * sin(x), // Cmaj7
  (D4 + F4 + A4 + C5) * sin(x), // Dm7
  (E4 + G4 + B4 + D5) * sin(x), // Em7
  (F4 + A4 + C5 + E5) * sin(x), // Fmaj7
  (G4 + B4 + D5 + F5) * sin(x), // G7
  (A4 + C5 + E5 + G5) * sin(x), // Am7
  (B4 + D5 + F5 + A5) * sin(x), // Bm7b5
  
  // Add more jazz progressions here ...
};

// Declare a global variable to store the current state of the LFSR
uint16_t lfsr = LFSR_SEED;

// Declare an array to store the polynomials for each arpeggio
uint16_t polys[POLY_COUNT];

// Declare an array to store the notes for each polynomial
uint16_t notes[POLY_COUNT];

// Declare an array to store the frequencies for each note
uint16_t freqs[] = {C4, D4, E4, F4, G4, A4, B4, C5};

// Declare a function to generate a random bit using the LFSR
uint8_t lfsr_bit() {

  // Shift the LFSR one bit to the right
  lfsr >>= 1;
  
  // If the least significant bit is 1, XOR the LFSR with the mask and return 1
  if (lfsr & 1) {
    lfsr ^= LFSR_MASK;
    return 1;
  }
  
  // Otherwise, return 0
  return 0;
}

// Declare a function to generate a random note using the LFSR
uint16_t lfsr_note() {
  // Declare a variable to store the note index
  uint8_t index = 0;
  
  // Generate three random bits using the LFSR and add them to the index
  index += lfsr_bit();
  index += lfsr_bit() << 1;
  index += lfsr_bit() << 2;
  
  // Return the frequency corresponding to the index
  return freqs[index];
}

// Declare a function to generate a polynomial using the LFSR
uint16_t lfsr_poly() {
  // Declare a variable to store the polynomial
  uint16_t poly = 0;
  
  // Generate eight random bits using the LFSR and add them to the polynomial
  poly += lfsr_bit();
  poly += lfsr_bit() << 1;
  poly += lfsr_bit() << 2;
  poly += lfsr_bit() << 3;
  poly += lfsr_bit() << 4;
  poly += lfsr_bit() << 5;
  poly += lfsr_bit() << 6;
  
   // Return the polynomial 
   return poly; 
}

// Declare a function to evaluate a polynomial at a given note 
uint16_t eval_poly(uint16_t poly, uint16_t note) { 
   // Declare a variable to store the result 
   uint16_t result = note; 
   
   // Loop through each bit of the polynomial 
   for (uint8_t i =0; i <8; i++) { 
      // If the bit is set, multiply the result by itself and add the note 
      if (poly & (1 << i)) { 
         result *= result; 
         result += note; 
      } 
   } 
   
   // Return the result modulo C5 to keep it within range 
   return result % C5; 
}

// Declare a function to play a note at a given frequency and duration 
void play_note(uint16_t frequency, uint16_t duration) { 
   // Use tone() function to generate a square wave at the speaker pin 
   tone(SPEAKER_PIN, frequency); 
   
   // Wait for the duration of the note 
   delay(duration); 
   
   // Stop playing the tone 
   noTone(SPEAKER_PIN);
}

// Declare a function to play an arpeggio using a given polynomial and note
void play_arpeggio(uint16_t poly, uint16_t note) {

  // Declare a variable to store the current note
  uint16_t current = note;
  
  // Loop through eight notes
  for (uint8_t i = 0; i < 8; i++) {
    // Play the current note
    play_note(current, NOTE_DURATION);
    
    // Print the current note and duration to the serial port in sound tracker format
    Serial.print(current);
    Serial.print(",");
    Serial.println(NOTE_DURATION);
    
    // Evaluate the polynomial at the current note and update it
    current = eval_poly(poly, current);
  }
}

// Declare a function to play a fractal chord using a given array of polynomials and notes
void play_fractal(uint16_t polys[], uint16_t notes[]) {
  // Declare a variable to store the sum of the notes
  uint16_t sum = 0;
  
  // Loop through each polynomial and note pair
  for (uint8_t i = 0; i < POLY_COUNT; i++) {
    // Evaluate the polynomial at the note and add it to the sum
    sum += eval_poly(polys[i], notes[i]);
  }
  
  // Play the sum as a chord
  play_note(sum, NOTE_DURATION * 8);
  
  // Print the sum and duration to the serial port in sound tracker format
  Serial.print(sum);
  Serial.print(",");
  Serial.println(NOTE_DURATION * 8);
}

// Declare a function to generate a sequence of arpeggios and fractal chords
void generate_sequence() {
  // Generate random polynomials using the LFSR
  for (uint8_t i = 0; i < POLY_COUNT; i++) {
    polys[i] = lfsr_poly();
  }
  
  // Generate random notes using the LFSR
  for (uint8_t i = 0; i < POLY_COUNT; i++) {
    notes[i] = lfsr_note();
  }
}

// Declare a function to evolve a sequence of arpeggios and fractal chords using gradient descent
void evolve_sequence() {

  // Declare a variable to store the error between the target and the current function
  uint16_t error = 0;
  
  // Declare a variable to store the gradient of the error with respect to each polynomial
  uint16_t grad[POLY_COUNT];
  
  // Loop through each polynomial and note pair
  for (uint8_t i = 0; i < POLY_COUNT; i++) {
    // Evaluate the polynomial at the note and subtract it from the target function
    error += TARGET_FUNCTION(notes[i]) - eval_poly(polys[i], notes[i]);
    
    // Calculate the gradient of the error with respect to the polynomial using finite difference approximation
    grad[i] = (error - (TARGET_FUNCTION(notes[i]) - eval_poly(polys[i] + 1, notes[i]))) / 1;
    
    // Update the polynomial using gradient descent
    polys[i] -= LEARNING_RATE * grad[i];
  }
}

// Declare a function to play a sequence of arpeggios and fractal chords
void play_sequence() {
  // Loop through a number of iterations
  for (uint8_t i = 0; i < ITER_COUNT; i++) {
    // Play an arpeggio for each polynomial and note pair
    for (uint8_t j = 0; j < POLY_COUNT; j++) {
      play_arpeggio(polys[j], notes[j]);
    }
    
    // Play a fractal chord using the polynomials and notes
    play_fractal(polys, notes);
    
    // Update the notes by evaluating the polynomials at them
    for (uint8_t j = 0; j < POLY_COUNT; j++) {
      notes[j] = eval_poly(polys[j], notes[j]);
    }
  }
}

// Declare a function to read the knob value and set the target function accordingly
void set_target() {
  // Read the analog value from the knob pin (between 0 and 1023)
  uint16_t value = analogRead(KNOB_PIN);
  
  // Map the value to an index between 0 and PROG_COUNT - 1
  uint8_t index = map(value, 0, 1023, 0, PROG_COUNT - 1);
  
  // Set the target function to the corresponding jazz progression
  TARGET_FUNCTION(x) = progs[index];
  
  // Check if the index is a multiple of PROG_COUNT / 4 (meaning no interpolation is needed)
  if (index % (PROG_COUNT / 4) == 0) {
    // Turn on the built-in LED
    digitalWrite(LED_BUILTIN, HIGH);
  } else {
    // Turn off the built-in LED
    digitalWrite(LED_BUILTIN, LOW);
  }
}

// Setup function to run once at the beginning
void setup() {

  // Set the speaker pin as an output
  pinMode(SPEAKER_PIN, OUTPUT);
  
  // Set the button pins as inputs with pull-up resistors
  pinMode(GENERATE_PIN, INPUT_PULLUP);
  pinMode(EVOLVE_PIN, INPUT_PULLUP);
  pinMode(REPEAT_PIN, INPUT_PULLUP);
  
  // Set the knob pin as an input
  pinMode(KNOB_PIN, INPUT);
  
  // Set the built-in LED pin as an output
  pinMode(LED_BUILTIN, OUTPUT);
  
  // Initialize serial communication at baud rate of 9600 bps
  Serial.begin(9600);
}

// Loop function to run repeatedly
void loop() {
  // Read the knob value and set the target function accordingly
  set_target();
  
  // Check if the generate button is pressed
  if (digitalRead(GENERATE_PIN) == LOW) {
    // Generate a new sequence of arpeggios and fractal chords
    generate_sequence();
    
    // Play the sequence
    play_sequence();
    
    // Wait for a second before repeating
    delay(1000);
  }
  
  // Check if the evolve button is pressed
  if (digitalRead(EVOLVE_PIN) == LOW) {
    // Evolve the current sequence of arpeggios and fractal chords using gradient descent
    evolve_sequence();
    
    // Play the sequence
    play_sequence();
    
    // Wait for a second before repeating
    delay(1000);
  }
  
  // Check if the repeat button is pressed
  if (digitalRead(REPEAT_PIN) == LOW) {
    // Repeat the current sequence of arpeggios and fractal chords
    play_sequence();
    
    // Wait for a second before repeating
    delay(1000);
  }
}
