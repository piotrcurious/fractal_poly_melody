
// Arduino sketch playing arpeggios generated by LFSR generated polynomials combinations converging to symmetrical fractal chords

// Define the pins for the speaker and the buttons
#define SPEAKER_PIN 9
#define GENERATE_PIN 2 // Button to generate a new sequence
#define EVOLVE_PIN 3 // Button to evolve the current sequence
#define REPEAT_PIN 4 // Button to repeat the current sequence

// Define the notes and frequencies for the arpeggios
#define C4 262
#define D4 294
#define E4 330
#define F4 349
#define G4 392
#define A4 440
#define B4 494
#define C5 523

// Define the duration of each note in milliseconds
#define NOTE_DURATION 100

// Define the LFSR parameters
#define LFSR_SEED 0xACE1 // Initial state of the LFSR
#define LFSR_MASK 0xB400 // Polynomial mask for the LFSR

// Define the number of polynomials to combine
#define POLY_COUNT 3

// Define the number of iterations to converge to a fractal chord
#define ITER_COUNT 5

// Declare a global variable to store the current state of the LFSR
uint16_t lfsr = LFSR_SEED;

// Declare an array to store the notes for each polynomial
uint16_t notes[POLY_COUNT];

// Declare an array to store the frequencies for each note
uint16_t freqs[] = {C4, D4, E4, F4, G4, A4, B4, C5};

// Declare a function to generate a random bit using the LFSR
uint8_t lfsr_bit() {
  // Shift the LFSR one bit to the right
  lfsr >>= 1;
  
  // If the least significant bit is 1, XOR the LFSR with the mask and return 1
  if (lfsr & 1) {
    lfsr ^= LFSR_MASK;
    return 1;
  }
  
  // Otherwise, return 0
  return 0;
}

// Declare a function to generate a random note using the LFSR
uint16_t lfsr_note() {
  // Declare a variable to store the note index
  uint8_t index = 0;
  
  // Generate three random bits using the LFSR and add them to the index
  index += lfsr_bit();
  index += lfsr_bit() << 1;
  index += lfsr_bit() << 2;
  
  // Return the frequency corresponding to the index
  return freqs[index];
}

// Declare a function to generate a polynomial using the LFSR
uint16_t lfsr_poly() {
  // Declare a variable to store the polynomial
  uint16_t poly = 0;
  
  // Generate eight random bits using the LFSR and add them to the polynomial
  poly += lfsr_bit();
  poly += lfsr_bit() << 1;
  poly += lfsr_bit() << 2;
  poly += lfsr_bit() << 3;
  poly += lfsr_bit() << 4;
  poly += lfsr_bit() << 5;
  poly += lfsr_bit() << 6;
  
   // Return the polynomial 
   return poly; 
}

// Declare a function to evaluate a polynomial at a given note 
uint16_t eval_poly(uint16_t poly, uint16_t note) { 
   // Declare a variable to store the result 
   uint16_t result = note; 
   
   // Loop through each bit of the polynomial 
   for (uint8_t i =0; i <8; i++) { 
      // If the bit is set, multiply the result by itself and add the note 
      if (poly & (1 << i)) { 
         result *= result; 
         result += note; 
      } 
   } 
   
   // Return the result modulo C5 to keep it within range 
   return result % C5; 
}

// Declare a function to play a note at a given frequency and duration 
void play_note(uint16_t frequency, uint16_t duration) { 
   // Use tone() function to generate a square wave at the speaker pin 
   tone(SPEAKER_PIN, frequency); 
   
   // Wait for the duration of the note 
   delay(duration); 
   
   // Stop playing the tone 
   noTone(SPEAKER_PIN);
}

// Declare a function to play an arpeggio using a given polynomial and note
void play_arpeggio(uint16_t poly, uint16_t note) {
  // Declare a variable to store the current note
  uint16_t current = note;
  
  // Loop through eight notes
  for (uint8_t i = 0; i < 8; i++) {
    // Play the current note
    play_note(current, NOTE_DURATION);
    
    // Print the current note and duration to the serial port in sound tracker format
    Serial.print(current);
    Serial.print(",");
    Serial.println(NOTE_DURATION);
    
    // Evaluate the polynomial at the current note and update it
    current = eval_poly(poly, current);
  }
}

// Declare a function to play a fractal chord using a given array of polynomials and notes
void play_fractal(uint16_t polys[], uint16_t notes[]) {
  // Declare a variable to store the sum of the notes
  uint16_t sum = 0;
  
  // Loop through each polynomial and note pair
  for (uint8_t i = 0; i < POLY_COUNT; i++) {
    // Evaluate the polynomial at the note and add it to the sum
    sum += eval_poly(polys[i], notes[i]);
  }
  
  // Play the sum as a chord
  play_note(sum, NOTE_DURATION * 8);
  
  // Print the sum and duration to the serial port in sound tracker format
  Serial.print(sum);
  Serial.print(",");
  Serial.println(NOTE_DURATION * 8);
}

// Declare a function to generate and play a sequence of arpeggios and fractal chords
void play_sequence() {
  // Generate random polynomials using the LFSR
  for (uint8_t i = 0; i < POLY_COUNT; i++) {
    notes[i] = lfsr_poly();
  }
  
  // Loop through a number of iterations
  for (uint8_t i = 0; i < ITER_COUNT; i++) {
    // Play an arpeggio for each polynomial and note pair
    for (uint8_t j = 0; j < POLY_COUNT; j++) {
      play_arpeggio(polys[j], notes[j]);
    }
    
    // Play a fractal chord using the polynomials and notes
    play_fractal(polys, notes);
    
    // Update the notes by evaluating the polynomials at them
    for (uint8_t j = 0; j < POLY_COUNT; j++) {
      notes[j] = eval_poly(polys[j], notes[j]);
    }
  }
}

// Setup function to run once at the beginning
void setup() {
  // Set the speaker pin as an output
  pinMode(SPEAKER_PIN, OUTPUT);
  
  // Set the button pins as inputs with pull-up resistors
  pinMode(GENERATE_PIN, INPUT_PULLUP);
  pinMode(EVOLVE_PIN, INPUT_PULLUP);
  pinMode(REPEAT_PIN, INPUT_PULLUP);
  
  // Initialize serial communication at baud rate of 9600 bps
  Serial.begin(9600);
}

// Loop function to run repeatedly
void loop() {

  // Check if the generate button is pressed
  if (digitalRead(GENERATE_PIN) == LOW) {
    // Generate and play a new sequence of arpeggios and fractal chords
    play_sequence();
    
    // Wait for a second before repeating
    delay(1000);
  }
  
  // Check if the evolve button is pressed
  if (digitalRead(EVOLVE_PIN) == LOW) {
    // Evolve and play the current sequence of arpeggios and fractal chords
    play_sequence();
    
    // Wait for a second before repeating
    delay(1000);
  }
  
  // Check if the repeat button is pressed
  if (digitalRead(REPEAT_PIN) == LOW) {
    // Repeat the current sequence of arpeggios and fractal chords
    play_sequence();
    
    // Wait for a second before repeating
    delay(1000);
  }
}
